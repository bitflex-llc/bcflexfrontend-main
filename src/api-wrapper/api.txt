/* tslint:disable */
/* eslint-disable */
/**
 * BCFLEX Public API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AffiliateDataResponse
 */
export interface AffiliateDataResponse {
    /**
     * 
     * @type {string}
     * @memberof AffiliateDataResponse
     */
    refId?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AffiliateDataResponse
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface ApiGetBalanceActions
 */
export interface ApiGetBalanceActions {
    /**
     * 
     * @type {string}
     * @memberof ApiGetBalanceActions
     */
    currency?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetBalanceActions
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiGetBalanceActions
     */
    dateTime?: number;
    /**
     * 
     * @type {BalanceActionType}
     * @memberof ApiGetBalanceActions
     */
    type?: BalanceActionType;
    /**
     * 
     * @type {string}
     * @memberof ApiGetBalanceActions
     */
    reasonText?: string | null;
}
/**
 * 
 * @export
 * @interface ApiGetDepositsWitdrawals
 */
export interface ApiGetDepositsWitdrawals {
    /**
     * 
     * @type {string}
     * @memberof ApiGetDepositsWitdrawals
     */
    currency?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetDepositsWitdrawals
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiGetDepositsWitdrawals
     */
    blockExURL?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiGetDepositsWitdrawals
     */
    txId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetDepositsWitdrawals
     */
    dateTime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ApiGetDepositsWitdrawals
     */
    pending?: boolean;
}
/**
 * 
 * @export
 * @interface ApiGetOrders
 */
export interface ApiGetOrders {
    /**
     * 
     * @type {string}
     * @memberof ApiGetOrders
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiGetOrders
     */
    pairName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    created?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    dateCreated?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    amountLeft?: number;
    /**
     * 
     * @type {TradeType}
     * @memberof ApiGetOrders
     */
    tradeType?: TradeType;
    /**
     * 
     * @type {OrderTypes}
     * @memberof ApiGetOrders
     */
    orderType?: OrderTypes;
    /**
     * 
     * @type {boolean}
     * @memberof ApiGetOrders
     */
    isMargin?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    liquidationPrice?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    initialPrice?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    leverage?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    initialAmount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    stopLossPrice?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApiGetOrders
     */
    takeProfitPrice?: number | null;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    key?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKey
     */
    isTradeAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKey
     */
    isMarginTradeAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApiKey
     */
    isWithdrawAllowed?: boolean;
}
/**
 * 
 * @export
 * @interface ApiMarket
 */
export interface ApiMarket {
    /**
     * 
     * @type {string}
     * @memberof ApiMarket
     */
    symbol?: string | null;
    /**
     * 
     * @type {Array<ApiPair>}
     * @memberof ApiMarket
     */
    pairs?: Array<ApiPair> | null;
}
/**
 * 
 * @export
 * @interface ApiPair
 */
export interface ApiPair {
    /**
     * 
     * @type {string}
     * @memberof ApiPair
     */
    pair?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApiPair
     */
    symbol?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiPair
     */
    leverage?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiPair
     */
    id?: string | null;
}
/**
 * 
 * @export
 * @interface ApiTickers
 */
export interface ApiTickers {
    /**
     * 
     * @type {string}
     * @memberof ApiTickers
     */
    pair?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApiTickers
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTickers
     */
    volume?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTickers
     */
    pairVolume?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTickers
     */
    high?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTickers
     */
    low?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTickers
     */
    change?: number;
    /**
     * 
     * @type {number}
     * @memberof ApiTickers
     */
    usdPrice?: number;
}
/**
 * 
 * @export
 * @interface ApplicationUser
 */
export interface ApplicationUser {
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    userName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    normalizedUserName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    normalizedEmail?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    emailConfirmed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    passwordHash?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    securityStamp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    concurrencyStamp?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    phoneNumber?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    phoneNumberConfirmed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    twoFactorEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    lockoutEnd?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    lockoutEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    accessFailedCount?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    fullname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    pinCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    lastIPAccess?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    lastDateAccess?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isChatDisabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    makerFee?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    takerFee?: number | null;
    /**
     * 
     * @type {UserCategory}
     * @memberof ApplicationUser
     */
    category?: UserCategory;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isGoogleSignInAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isFacebookSignInAllowed?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    registrationDateTime?: number;
    /**
     * 
     * @type {number}
     * @memberof ApplicationUser
     */
    verificationLevel?: number | null;
    /**
     * 
     * @type {TwoStepVerificationTypes}
     * @memberof ApplicationUser
     */
    twoStepVerificationType?: TwoStepVerificationTypes;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    twoStepBackupCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    kycSefileBlobGuid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    kycPassportBlobGuid?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationUser
     */
    isClubAccount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationUser
     */
    refId?: string | null;
}
/**
 * 
 * @export
 * @interface AskForPermissionRequestModel
 */
export interface AskForPermissionRequestModel {
    /**
     * 
     * @type {DevicePermissionRequestType}
     * @memberof AskForPermissionRequestModel
     */
    type?: DevicePermissionRequestType;
    /**
     * 
     * @type {string}
     * @memberof AskForPermissionRequestModel
     */
    bitflexDeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AskForPermissionRequestModel
     */
    terminalSignalRConnectionId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AskForPermissionRequestModel
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AskForPermissionRequestModel
     */
    ipAddress?: string | null;
    /**
     * 
     * @type {ClientInfo}
     * @memberof AskForPermissionRequestModel
     */
    clientInfo?: ClientInfo;
    /**
     * 
     * @type {number}
     * @memberof AskForPermissionRequestModel
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof AskForPermissionRequestModel
     */
    longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof AskForPermissionRequestModel
     */
    location?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AskForPermissionRequestModel
     */
    deviceDescription?: string | null;
}
/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {string}
     * @memberof Balance
     */
    currencyId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    amount?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum BalanceAction {
    Deposit = 'Deposit',
    Withdraw = 'Withdraw'
}

/**
 * 
 * @export
 * @interface BalanceActionModel
 */
export interface BalanceActionModel {
    /**
     * 
     * @type {BalanceAction}
     * @memberof BalanceActionModel
     */
    action?: BalanceAction;
    /**
     * 
     * @type {string}
     * @memberof BalanceActionModel
     */
    currencyId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BalanceActionModel
     */
    userId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BalanceActionModel
     */
    amount?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum BalanceActionType {
    Deposit = 'Deposit',
    Withdraw = 'Withdraw'
}

/**
 * 
 * @export
 * @interface BalanceErrorCode
 */
export interface BalanceErrorCode {
    /**
     * 
     * @type {boolean}
     * @memberof BalanceErrorCode
     */
    success?: boolean;
    /**
     * 
     * @type {Code}
     * @memberof BalanceErrorCode
     */
    errorCode?: Code;
    /**
     * 
     * @type {string}
     * @memberof BalanceErrorCode
     */
    errorMessage?: string | null;
}
/**
 * 
 * @export
 * @interface BitflexApiResponseBase
 */
export interface BitflexApiResponseBase {
    /**
     * 
     * @type {boolean}
     * @memberof BitflexApiResponseBase
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface BooleanBooleanBooleanTuple
 */
export interface BooleanBooleanBooleanTuple {
    /**
     * 
     * @type {boolean}
     * @memberof BooleanBooleanBooleanTuple
     */
    item1?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BooleanBooleanBooleanTuple
     */
    item2?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BooleanBooleanBooleanTuple
     */
    item3?: boolean;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    oldPassword: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface Check2StepVerificationStatusResponse
 */
export interface Check2StepVerificationStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof Check2StepVerificationStatusResponse
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Check2StepVerificationStatusResponse
     */
    isThisDeviceLegit?: boolean;
    /**
     * 
     * @type {TwoStepVerificationTypes}
     * @memberof Check2StepVerificationStatusResponse
     */
    verificationType?: TwoStepVerificationTypes;
}
/**
 * 
 * @export
 * @interface ClientInfo
 */
export interface ClientInfo {
    /**
     * 
     * @type {string}
     * @memberof ClientInfo
     */
    string?: string | null;
    /**
     * 
     * @type {OS}
     * @memberof ClientInfo
     */
    os?: OS;
    /**
     * 
     * @type {Device}
     * @memberof ClientInfo
     */
    device?: Device;
    /**
     * 
     * @type {UserAgent}
     * @memberof ClientInfo
     */
    userAgent?: UserAgent;
    /**
     * 
     * @type {UserAgent}
     * @memberof ClientInfo
     */
    ua?: UserAgent;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Code {
    WrongCurrency = 'WrongCurrency',
    CurrencyNotFound = 'CurrencyNotFound',
    Unauthenticated = 'Unauthenticated',
    GenerationError = 'GenerationError',
    CreateError = 'CreateError'
}

/**
 * 
 * @export
 * @interface CoinTokenAddRequest
 */
export interface CoinTokenAddRequest {
    /**
     * 
     * @type {string}
     * @memberof CoinTokenAddRequest
     */
    cmcUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CoinTokenAddRequest
     */
    contractAddress?: string | null;
    /**
     * 
     * @type {Type}
     * @memberof CoinTokenAddRequest
     */
    currencyType?: Type;
    /**
     * 
     * @type {string}
     * @memberof CoinTokenAddRequest
     */
    explolerUrl?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CoinTokenAddRequest
     */
    withdrawFee?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CoinTokenAddRequest
     */
    withdrawFeePercent?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CoinTokenAddRequest
     */
    confirmationCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CoinTokenAddRequest
     */
    decimals?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CoinTokenAddRequest
     */
    rpcIP?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CoinTokenAddRequest
     */
    rpcPort?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CoinTokenAddRequest
     */
    rpcUsername?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CoinTokenAddRequest
     */
    rpcPassword?: string | null;
}
/**
 * 
 * @export
 * @interface CryptoCurrency
 */
export interface CryptoCurrency {
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    shortName?: string | null;
    /**
     * 
     * @type {Type}
     * @memberof CryptoCurrency
     */
    currencyType?: Type;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    depositDisabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    withdrawDisabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapId?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapUsdPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapLastUpdate?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapMaxSupply?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapTotalSupply?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    coinMarketCapCurculatingSupply?: number;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    coinMarketCapDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    coinMarketCapIssueDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    coinMarketCapExplolerUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    image?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CryptoCurrency
     */
    isMarketCurrency?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CryptoCurrency
     */
    blockExplolerTxIdUrl?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    withdrawCurrencyFee?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    confirmationCount?: number;
    /**
     * 
     * @type {number}
     * @memberof CryptoCurrency
     */
    minimumTradeAmount?: number;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    isSpider?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    brand?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    family?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    model?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DevicePermissionRequestType {
    EnableTwoFactor = 'EnableTwoFactor',
    CancelEnableTwoFactor = 'CancelEnableTwoFactor',
    DisableTwoFactor = 'DisableTwoFactor',
    ConfirmLogin = 'ConfirmLogin',
    ConfirmWithdraw = 'ConfirmWithdraw',
    CheckIsOnline = 'CheckIsOnline'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DeviceType {
    IOs = 'iOS',
    Android = 'Android',
    Chrome = 'Chrome',
    Safari = 'Safari'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EmailConfirmationErrorCode {
    Success = 'Success',
    UserOrCodeEmpty = 'UserOrCodeEmpty',
    UserNotFound = 'UserNotFound',
    WrongCode = 'WrongCode'
}

/**
 * 
 * @export
 * @interface EmailConfirmationResult
 */
export interface EmailConfirmationResult {
    /**
     * 
     * @type {boolean}
     * @memberof EmailConfirmationResult
     */
    result?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmailConfirmationResult
     */
    accessToken?: string | null;
    /**
     * 
     * @type {EmailConfirmationErrorCode}
     * @memberof EmailConfirmationResult
     */
    errorCode?: EmailConfirmationErrorCode;
    /**
     * 
     * @type {string}
     * @memberof EmailConfirmationResult
     */
    errorText?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EmailConfirmationResult
     */
    email?: string | null;
}
/**
 * 
 * @export
 * @interface EnableDisable2Fa
 */
export interface EnableDisable2Fa {
    /**
     * 
     * @type {string}
     * @memberof EnableDisable2Fa
     */
    clientCode: string;
    /**
     * 
     * @type {string}
     * @memberof EnableDisable2Fa
     */
    pincode: string;
    /**
     * 
     * @type {string}
     * @memberof EnableDisable2Fa
     */
    backupCode: string;
}
/**
 * 
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * 
     * @type {boolean}
     * @memberof ErrorModel
     */
    result?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ErrorModel
     */
    message?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ErrorModel
     */
    data?: any | null;
}
/**
 * 
 * @export
 * @interface FinishTier1VerificationModel
 */
export interface FinishTier1VerificationModel {
    /**
     * 
     * @type {string}
     * @memberof FinishTier1VerificationModel
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof FinishTier1VerificationModel
     */
    fullName: string;
}
/**
 * 
 * @export
 * @interface GenerateAddressResult
 */
export interface GenerateAddressResult {
    /**
     * 
     * @type {boolean}
     * @memberof GenerateAddressResult
     */
    result?: boolean;
    /**
     * 
     * @type {GetAddressResponse}
     * @memberof GenerateAddressResult
     */
    depositParam?: GetAddressResponse;
    /**
     * 
     * @type {BalanceErrorCode}
     * @memberof GenerateAddressResult
     */
    errorCode?: BalanceErrorCode;
}
/**
 * 
 * @export
 * @interface GenerateApiKeyRequest
 */
export interface GenerateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof GenerateApiKeyRequest
     */
    name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateApiKeyRequest
     */
    isTradeAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateApiKeyRequest
     */
    isMarginTradeAllowed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GenerateApiKeyRequest
     */
    isWithdrawAllowed?: boolean;
}
/**
 * 
 * @export
 * @interface GetAccessTokensResponse
 */
export interface GetAccessTokensResponse {
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokensResponse
     */
    id?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetAccessTokensResponse
     */
    expiration?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokensResponse
     */
    description?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetAccessTokensResponse
     */
    isThisDevice?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokensResponse
     */
    terminateReason?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetAccessTokensResponse
     */
    isOnline?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokensResponse
     */
    lastIP?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokensResponse
     */
    lastActive?: string;
}
/**
 * 
 * @export
 * @interface GetAddressResponse
 */
export interface GetAddressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetAddressResponse
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    address?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetAddressResponse
     */
    isAddressGenerated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    currency?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    fullname?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetAddressResponse
     */
    totalAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAddressResponse
     */
    availableAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetAddressResponse
     */
    confirmationCount?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    destinationTag?: string | null;
    /**
     * 
     * @type {Type}
     * @memberof GetAddressResponse
     */
    currencyType?: Type;
    /**
     * 
     * @type {boolean}
     * @memberof GetAddressResponse
     */
    isManual?: boolean;
    /**
     * 
     * @type {BalanceErrorCode}
     * @memberof GetAddressResponse
     */
    errorCode?: BalanceErrorCode;
}
/**
 * 
 * @export
 * @interface GetApiMarketsCurrenciesResponse
 */
export interface GetApiMarketsCurrenciesResponse {
    /**
     * 
     * @type {string}
     * @memberof GetApiMarketsCurrenciesResponse
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetApiMarketsCurrenciesResponse
     */
    symbol?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetApiMarketsCurrenciesResponse
     */
    imageBase64?: string | null;
    /**
     * 
     * @type {Type}
     * @memberof GetApiMarketsCurrenciesResponse
     */
    type?: Type;
}
/**
 * 
 * @export
 * @interface GetBalanceActionsResponse
 */
export interface GetBalanceActionsResponse {
    /**
     * 
     * @type {Array<ApiGetBalanceActions>}
     * @memberof GetBalanceActionsResponse
     */
    actions?: Array<ApiGetBalanceActions> | null;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceActionsResponse
     */
    pages?: number;
}
/**
 * 
 * @export
 * @interface GetBalanceHoldAndLimits
 */
export interface GetBalanceHoldAndLimits {
    /**
     * 
     * @type {number}
     * @memberof GetBalanceHoldAndLimits
     */
    usdHoldings?: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceHoldAndLimits
     */
    btcHoldings?: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceHoldAndLimits
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceHoldAndLimits
     */
    usedLimit?: number;
}
/**
 * 
 * @export
 * @interface GetBalanceRequestModel
 */
export interface GetBalanceRequestModel {
    /**
     * 
     * @type {string}
     * @memberof GetBalanceRequestModel
     */
    currency?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceRequestModel
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceRequestModel
     */
    onOrders?: number;
    /**
     * 
     * @type {number}
     * @memberof GetBalanceRequestModel
     */
    available?: number;
    /**
     * 
     * @type {BalanceErrorCode}
     * @memberof GetBalanceRequestModel
     */
    errorCode?: BalanceErrorCode;
}
/**
 * 
 * @export
 * @interface GetBalancesListResponse
 */
export interface GetBalancesListResponse {
    /**
     * 
     * @type {Array<GetBalanceRequestModel>}
     * @memberof GetBalancesListResponse
     */
    balances?: Array<GetBalanceRequestModel> | null;
    /**
     * 
     * @type {GetBalanceHoldAndLimits}
     * @memberof GetBalancesListResponse
     */
    stats?: GetBalanceHoldAndLimits;
}
/**
 * 
 * @export
 * @interface GetMarketsResponse
 */
export interface GetMarketsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetMarketsResponse
     */
    result?: boolean;
    /**
     * 
     * @type {StatusCodeEnum}
     * @memberof GetMarketsResponse
     */
    code?: StatusCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof GetMarketsResponse
     */
    fingerprint?: string | null;
    /**
     * 
     * @type {Array<ApiMarket>}
     * @memberof GetMarketsResponse
     */
    markets?: Array<ApiMarket> | null;
}
/**
 * 
 * @export
 * @interface GetOrdersResponse
 */
export interface GetOrdersResponse {
    /**
     * 
     * @type {Array<ApiGetOrders>}
     * @memberof GetOrdersResponse
     */
    openOrders?: Array<ApiGetOrders> | null;
    /**
     * 
     * @type {Array<ApiGetOrders>}
     * @memberof GetOrdersResponse
     */
    closedOrders?: Array<ApiGetOrders> | null;
}
/**
 * 
 * @export
 * @interface GetTickeAsyncResponse
 */
export interface GetTickeAsyncResponse {
    /**
     * 
     * @type {ServerLocation}
     * @memberof GetTickeAsyncResponse
     */
    location?: ServerLocation;
    /**
     * 
     * @type {number}
     * @memberof GetTickeAsyncResponse
     */
    timestamp?: number;
}
/**
 * 
 * @export
 * @interface GetTickersResponse
 */
export interface GetTickersResponse {
    /**
     * 
     * @type {boolean}
     * @memberof GetTickersResponse
     */
    result?: boolean;
    /**
     * 
     * @type {StatusCodeEnum}
     * @memberof GetTickersResponse
     */
    code?: StatusCodeEnum;
    /**
     * 
     * @type {Array<ApiTickers>}
     * @memberof GetTickersResponse
     */
    tickers?: Array<ApiTickers> | null;
}
/**
 * 
 * @export
 * @interface GetTradeHistoryResponse
 */
export interface GetTradeHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof GetTradeHistoryResponse
     */
    dateTime?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTradeHistoryResponse
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTradeHistoryResponse
     */
    amount?: number;
    /**
     * 
     * @type {TradeType}
     * @memberof GetTradeHistoryResponse
     */
    type?: TradeType;
}
/**
 * 
 * @export
 * @interface GetVerificationLevelResponse
 */
export interface GetVerificationLevelResponse {
    /**
     * 
     * @type {number}
     * @memberof GetVerificationLevelResponse
     */
    verificationLevel?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof GetVerificationLevelResponse
     */
    withdrawLimits?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface GetWithdrawResponse
 */
export interface GetWithdrawResponse {
    /**
     * 
     * @type {string}
     * @memberof GetWithdrawResponse
     */
    longName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetWithdrawResponse
     */
    totalAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetWithdrawResponse
     */
    availableAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetWithdrawResponse
     */
    maximumWithdrawAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof GetWithdrawResponse
     */
    withdrawFeePercent?: number;
    /**
     * 
     * @type {number}
     * @memberof GetWithdrawResponse
     */
    withdrawFee?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetWithdrawResponse
     */
    needDestinationTag?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetWithdrawResponse
     */
    destinationTagName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetWithdrawResponse
     */
    withdrawDisabled?: boolean;
    /**
     * 
     * @type {BalanceErrorCode}
     * @memberof GetWithdrawResponse
     */
    errorCode?: BalanceErrorCode;
}
/**
 * 
 * @export
 * @interface OS
 */
export interface OS {
    /**
     * 
     * @type {string}
     * @memberof OS
     */
    family?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OS
     */
    major?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OS
     */
    minor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OS
     */
    patch?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OS
     */
    patchMinor?: string | null;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    id?: string | null;
    /**
     * 
     * @type {TradeType}
     * @memberof Order
     */
    tradeType?: TradeType;
    /**
     * 
     * @type {OrderTypes}
     * @memberof Order
     */
    orderType?: OrderTypes;
    /**
     * 
     * @type {OrderState}
     * @memberof Order
     */
    orderState?: OrderState;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    tradePairname?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    amountLeft?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    stopLossPrice?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    takeProfitPrice?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    isMargin?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    liquidationPrice?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    initialPrice?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    leverage?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    initialAmount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    closePositionPrice?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    dateCreated?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    dateClosed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    dateOnMarket?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    closed?: boolean;
}
/**
 * 
 * @export
 * @interface OrderCancelResult
 */
export interface OrderCancelResult {
    /**
     * 
     * @type {boolean}
     * @memberof OrderCancelResult
     */
    result?: boolean;
}
/**
 * 
 * @export
 * @interface OrderCreateResult
 */
export interface OrderCreateResult {
    /**
     * 
     * @type {boolean}
     * @memberof OrderCreateResult
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderCreateResult
     */
    errorMessage?: string | null;
    /**
     * 
     * @type {Order}
     * @memberof OrderCreateResult
     */
    order?: Order;
    /**
     * 
     * @type {Array<Balance>}
     * @memberof OrderCreateResult
     */
    balance?: Array<Balance> | null;
    /**
     * 
     * @type {number}
     * @memberof OrderCreateResult
     */
    execution?: number;
    /**
     * 
     * @type {Array<TradesGetViewModel>}
     * @memberof OrderCreateResult
     */
    trades?: Array<TradesGetViewModel> | null;
    /**
     * 
     * @type {Array<BalanceActionModel>}
     * @memberof OrderCreateResult
     */
    balanceActions?: Array<BalanceActionModel> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderState {
    WaitingForActivation = 'WaitingForActivation',
    OnMarket = 'OnMarket',
    PartiallyFilled = 'PartiallyFilled',
    Cancelled = 'Cancelled',
    Rejected = 'Rejected',
    CloseFilled = 'Close_Filled',
    CancelledByUser = 'Cancelled_ByUser',
    CloseMarginCall = 'Close_MarginCall'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderTypes {
    Market = 'Market',
    Limit = 'Limit',
    StopLossLimit = 'StopLossLimit',
    TakeProfitLimit = 'TakeProfitLimit',
    StopLossMarket = 'StopLossMarket',
    Oco = 'OCO'
}

/**
 * 
 * @export
 * @interface OrderViewModel
 */
export interface OrderViewModel {
    /**
     * 
     * @type {number}
     * @memberof OrderViewModel
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderViewModel
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface OrdersGetViewModel
 */
export interface OrdersGetViewModel {
    /**
     * 
     * @type {Array<OrderViewModel>}
     * @memberof OrdersGetViewModel
     */
    sell?: Array<OrderViewModel> | null;
    /**
     * 
     * @type {Array<OrderViewModel>}
     * @memberof OrdersGetViewModel
     */
    buy?: Array<OrderViewModel> | null;
}
/**
 * 
 * @export
 * @interface PinCodeRequestModel
 */
export interface PinCodeRequestModel {
    /**
     * 
     * @type {string}
     * @memberof PinCodeRequestModel
     */
    oldPinCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PinCodeRequestModel
     */
    newPinCode?: string | null;
}
/**
 * 
 * @export
 * @interface PostConfirmPermissionSignInRequest
 */
export interface PostConfirmPermissionSignInRequest {
    /**
     * 
     * @type {string}
     * @memberof PostConfirmPermissionSignInRequest
     */
    id?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PostConfirmPermissionSignInRequest
     */
    isTradingEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostConfirmPermissionSignInRequest
     */
    isMarginTradingEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostConfirmPermissionSignInRequest
     */
    isWithdrawEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PostConfirmPermissionSignInRequest
     */
    isDatachangeEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface PostConfirmRequest
 */
export interface PostConfirmRequest {
    /**
     * 
     * @type {string}
     * @memberof PostConfirmRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof PostConfirmRequest
     */
    code: string;
    /**
     * 
     * @type {boolean}
     * @memberof PostConfirmRequest
     */
    isInApp?: boolean;
}
/**
 * 
 * @export
 * @interface PostForgotPasswordRequest
 */
export interface PostForgotPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof PostForgotPasswordRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface PostMobileConfirmationRequestModel
 */
export interface PostMobileConfirmationRequestModel {
    /**
     * 
     * @type {RequestType}
     * @memberof PostMobileConfirmationRequestModel
     */
    requestType?: RequestType;
    /**
     * 
     * @type {string}
     * @memberof PostMobileConfirmationRequestModel
     */
    bitflexDeviceId?: string | null;
}
/**
 * 
 * @export
 * @interface PostOrdersRequest
 */
export interface PostOrdersRequest {
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    price?: number;
    /**
     * 
     * @type {TradeType}
     * @memberof PostOrdersRequest
     */
    tradeType?: TradeType;
    /**
     * 
     * @type {string}
     * @memberof PostOrdersRequest
     */
    pairId?: string | null;
    /**
     * 
     * @type {OrderTypes}
     * @memberof PostOrdersRequest
     */
    orderType?: OrderTypes;
    /**
     * 
     * @type {boolean}
     * @memberof PostOrdersRequest
     */
    isMargin?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    leverage?: number;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    initialAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    initialPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    stopLossPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof PostOrdersRequest
     */
    takeProfitPrice?: number;
}
/**
 * 
 * @export
 * @interface PostResetPasswordRequest
 */
export interface PostResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof PostResetPasswordRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof PostResetPasswordRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof PostResetPasswordRequest
     */
    code: string;
}
/**
 * 
 * @export
 * @interface PostSignInRequest
 */
export interface PostSignInRequest {
    /**
     * 
     * @type {string}
     * @memberof PostSignInRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof PostSignInRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof PostSignInRequest
     */
    reCaptchav3Token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PostSignInRequest
     */
    bitflexDeviceId: string;
    /**
     * 
     * @type {string}
     * @memberof PostSignInRequest
     */
    googleTfaCode?: string | null;
}
/**
 * 
 * @export
 * @interface PostSignInResponse
 */
export interface PostSignInResponse {
    /**
     * 
     * @type {SignInResponseResult}
     * @memberof PostSignInResponse
     */
    result?: SignInResponseResult;
    /**
     * 
     * @type {string}
     * @memberof PostSignInResponse
     */
    authToken?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PostSignInResponse
     */
    expiryTimestamp?: number;
    /**
     * 
     * @type {TwoStepVerificationTypes}
     * @memberof PostSignInResponse
     */
    twoFactorType?: TwoStepVerificationTypes;
    /**
     * 
     * @type {string}
     * @memberof PostSignInResponse
     */
    email?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PostSignInResponse
     */
    userId?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PostSignInResponse
     */
    requrePinSetting?: boolean;
}
/**
 * 
 * @export
 * @interface PostSignUpRequest
 */
export interface PostSignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof PostSignUpRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof PostSignUpRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof PostSignUpRequest
     */
    pinCode?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PostSignUpRequest
     */
    isInApp?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostSignUpRequest
     */
    refId?: string | null;
}
/**
 * 
 * @export
 * @interface PostSignUpResponse
 */
export interface PostSignUpResponse {
    /**
     * 
     * @type {SignUpResponseResult}
     * @memberof PostSignUpResponse
     */
    result?: SignUpResponseResult;
    /**
     * 
     * @type {ErrorModel}
     * @memberof PostSignUpResponse
     */
    error?: ErrorModel;
}
/**
 * 
 * @export
 * @interface PostVefirySms
 */
export interface PostVefirySms {
    /**
     * 
     * @type {string}
     * @memberof PostVefirySms
     */
    phoneNumber: string;
    /**
     * 
     * @type {string}
     * @memberof PostVefirySms
     */
    code: string;
}
/**
 * 
 * @export
 * @interface PostWithdrawRequest
 */
export interface PostWithdrawRequest {
    /**
     * 
     * @type {number}
     * @memberof PostWithdrawRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    currency: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    destinationTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequest
     */
    googleAuthenticatorCode: string;
}
/**
 * 
 * @export
 * @interface PostWithdrawRequestResult
 */
export interface PostWithdrawRequestResult {
    /**
     * 
     * @type {boolean}
     * @memberof PostWithdrawRequestResult
     */
    success?: boolean;
    /**
     * 
     * @type {WithdrawErrorCode}
     * @memberof PostWithdrawRequestResult
     */
    withdrawErrorCode?: WithdrawErrorCode;
    /**
     * 
     * @type {string}
     * @memberof PostWithdrawRequestResult
     */
    withdrawId?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PrecheckLogoutResult {
    CanLogout = 'CanLogout',
    CanLogoutOtherDeviceAvailable = 'CanLogout_OtherDeviceAvailable',
    Cannot = 'Cannot'
}

/**
 * 
 * @export
 * @interface PriceAlert
 */
export interface PriceAlert {
    /**
     * 
     * @type {string}
     * @memberof PriceAlert
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PriceAlert
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PriceAlert
     */
    pairId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PriceAlert
     */
    price?: number;
    /**
     * 
     * @type {PriceAlertCompareType}
     * @memberof PriceAlert
     */
    comparer?: PriceAlertCompareType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PriceAlertCompareType {
    LessOrEqual = 'LessOrEqual',
    MoreOrEqual = 'MoreOrEqual'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PriceAlertCreateStatus {
    Created = 'Created',
    FailAlreadyExists = 'Fail_AlreadyExists',
    SystemError = 'SystemError'
}

/**
 * 
 * @export
 * @interface ProcessFaceImageRequest
 */
export interface ProcessFaceImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessFaceImageRequest
     */
    containerUUID?: string | null;
}
/**
 * 
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    currency?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Rate
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface RequestSettingsTokenResponseModel
 */
export interface RequestSettingsTokenResponseModel {
    /**
     * 
     * @type {boolean}
     * @memberof RequestSettingsTokenResponseModel
     */
    success?: boolean;
    /**
     * 
     * @type {SettingsTokenRequestErrorType}
     * @memberof RequestSettingsTokenResponseModel
     */
    errorType?: SettingsTokenRequestErrorType;
    /**
     * 
     * @type {string}
     * @memberof RequestSettingsTokenResponseModel
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RequestSettingsTokenResponseModel
     */
    expiration?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestSettingsTokenResponseModel
     */
    supportPIN?: number;
    /**
     * 
     * @type {TwoStepVerificationTypes}
     * @memberof RequestSettingsTokenResponseModel
     */
    verificationTypes?: TwoStepVerificationTypes;
    /**
     * 
     * @type {number}
     * @memberof RequestSettingsTokenResponseModel
     */
    sessionLifeTimeMinutes?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestSettingsTokenResponseModel
     */
    verificationLevel?: number;
    /**
     * 
     * @type {BooleanBooleanBooleanTuple}
     * @memberof RequestSettingsTokenResponseModel
     */
    signInNotification?: BooleanBooleanBooleanTuple;
    /**
     * 
     * @type {BooleanBooleanBooleanTuple}
     * @memberof RequestSettingsTokenResponseModel
     */
    withdrawNotification?: BooleanBooleanBooleanTuple;
    /**
     * 
     * @type {BooleanBooleanBooleanTuple}
     * @memberof RequestSettingsTokenResponseModel
     */
    depositNotification?: BooleanBooleanBooleanTuple;
    /**
     * 
     * @type {BooleanBooleanBooleanTuple}
     * @memberof RequestSettingsTokenResponseModel
     */
    listingNotification?: BooleanBooleanBooleanTuple;
    /**
     * 
     * @type {BooleanBooleanBooleanTuple}
     * @memberof RequestSettingsTokenResponseModel
     */
    delistingNotification?: BooleanBooleanBooleanTuple;
}
/**
 * 
 * @export
 * @interface RequestSettingsTokenResponseRequestModel
 */
export interface RequestSettingsTokenResponseRequestModel {
    /**
     * 
     * @type {string}
     * @memberof RequestSettingsTokenResponseRequestModel
     */
    pinCode?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RequestSettingsTokenResponseRequestModel
     */
    biometryIdentified?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestType {
    EnableTwoFactor = 'EnableTwoFactor',
    CancelEnableTwoFactor = 'CancelEnableTwoFactor',
    DisableTwoFactor = 'DisableTwoFactor',
    ConfirmLogin = 'ConfirmLogin',
    ConfirmWithdraw = 'ConfirmWithdraw',
    CheckIsOnline = 'CheckIsOnline'
}

/**
 * 
 * @export
 * @interface RestorePinPostRequest
 */
export interface RestorePinPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RestorePinPostRequest
     */
    email: string;
}
/**
 * 
 * @export
 * @interface RevokeTokenByIdRequestModel
 */
export interface RevokeTokenByIdRequestModel {
    /**
     * 
     * @type {string}
     * @memberof RevokeTokenByIdRequestModel
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RevokeTokenByIdRequestModel
     */
    reasonText?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ServerLocation {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2,
    NUMBER_3 = 3,
    NUMBER_4 = 4
}

/**
 * 
 * @export
 * @interface SetPriceAlertRequestModel
 */
export interface SetPriceAlertRequestModel {
    /**
     * 
     * @type {string}
     * @memberof SetPriceAlertRequestModel
     */
    pairName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SetPriceAlertRequestModel
     */
    price?: number;
    /**
     * 
     * @type {PriceAlertCompareType}
     * @memberof SetPriceAlertRequestModel
     */
    comparer?: PriceAlertCompareType;
}
/**
 * 
 * @export
 * @interface SetPriceAlertResponseModel
 */
export interface SetPriceAlertResponseModel {
    /**
     * 
     * @type {PriceAlertCreateStatus}
     * @memberof SetPriceAlertResponseModel
     */
    status?: PriceAlertCreateStatus;
    /**
     * 
     * @type {Array<PriceAlert>}
     * @memberof SetPriceAlertResponseModel
     */
    currentAlerts?: Array<PriceAlert> | null;
}
/**
 * 
 * @export
 * @interface SetPushTokenRequest
 */
export interface SetPushTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof SetPushTokenRequest
     */
    pushToken?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetPushTokenRequest
     */
    description?: string | null;
    /**
     * 
     * @type {DeviceType}
     * @memberof SetPushTokenRequest
     */
    device?: DeviceType;
    /**
     * 
     * @type {string}
     * @memberof SetPushTokenRequest
     */
    publicKey?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SettingsTokenRequestErrorType {
    WrongPinCode = 'WrongPinCode',
    DeviceNotAllowed = 'DeviceNotAllowed',
    PreviousNotExpired = 'PreviousNotExpired'
}

/**
 * 
 * @export
 * @interface SetupCode
 */
export interface SetupCode {
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    account?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    accountSecretKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    manualEntryKey?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    qrCodeSetupImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SetupCode
     */
    otpCleanUrl?: string | null;
}
/**
 * 
 * @export
 * @interface SignInPermissionModel
 */
export interface SignInPermissionModel {
    /**
     * 
     * @type {DevicePermissionRequestType}
     * @memberof SignInPermissionModel
     */
    type?: DevicePermissionRequestType;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    bitflexDeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    terminalSignalRConnectionId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    userId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    ipAddress?: string | null;
    /**
     * 
     * @type {ClientInfo}
     * @memberof SignInPermissionModel
     */
    clientInfo?: ClientInfo;
    /**
     * 
     * @type {number}
     * @memberof SignInPermissionModel
     */
    latitude?: number;
    /**
     * 
     * @type {number}
     * @memberof SignInPermissionModel
     */
    longitude?: number;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    location?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    deviceDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SignInPermissionModel
     */
    validTill?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SignInResponseResult {
    WrongCredentials = 'WrongCredentials',
    WrongPassword = 'WrongPassword',
    EmailNotConfirmed = 'EmailNotConfirmed',
    RequireTwoFactor = 'RequireTwoFactor',
    Success = 'Success',
    ReCaptchav3Failed = 'ReCaptchav3Failed',
    BitflexDeviceIdIsNotPresent = 'BitflexDeviceIdIsNotPresent',
    GoogleTfaWrong = 'GoogleTfaWrong'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SignUpResponseResult {
    BadInput = 'BadInput',
    FailCreation = 'FailCreation',
    SuccessEmailSent = 'SuccessEmailSent'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SmsVefiryResult {
    Success = 'Success',
    Fail = 'Fail',
    SystemError = 'SystemError'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum StatusCodeEnum {
    Success = 'Success',
    Error = 'Error',
    UpToDate = 'UpToDate'
}

/**
 * 
 * @export
 * @interface TradeData
 */
export interface TradeData {
    /**
     * 
     * @type {Array<Order>}
     * @memberof TradeData
     */
    orders?: Array<Order> | null;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TradeData
     */
    transactions?: Array<Transaction> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TradeType {
    Buy = 'Buy',
    Sell = 'Sell'
}

/**
 * 
 * @export
 * @interface TradesGetViewModel
 */
export interface TradesGetViewModel {
    /**
     * 
     * @type {number}
     * @memberof TradesGetViewModel
     */
    dateTime?: number;
    /**
     * 
     * @type {number}
     * @memberof TradesGetViewModel
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof TradesGetViewModel
     */
    amount?: number;
    /**
     * 
     * @type {TradeType}
     * @memberof TradesGetViewModel
     */
    type?: TradeType;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    txId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    date?: number;
    /**
     * 
     * @type {TransactionDirection}
     * @memberof Transaction
     */
    direction?: TransactionDirection;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    done?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransactionDirection {
    In = 'In',
    Out = 'Out'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TwoStepVerificationTypes {
   BCFLEX = 'BITFLEX',
    Google = 'Google'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum Type {
    BtcBased = 'BtcBased',
    EthBased = 'EthBased',
    Fiat = 'Fiat',
    Ripple = 'Ripple',
    Eos = 'Eos',
    Erc20 = 'ERC20'
}

/**
 * 
 * @export
 * @interface UpdatePublicKeyRequest
 */
export interface UpdatePublicKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    bitflexDeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    publicKeyPEM?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    publicKeyPKCS8?: string | null;
    /**
     * 
     * @type {DeviceType}
     * @memberof UpdatePublicKeyRequest
     */
    deviceType?: DeviceType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum UserAdminCommand {
    BlockUser = 'BlockUser',
    UnblockUser = 'UnblockUser',
    VerifyEmail = 'VerifyEmail',
    TwoFactorDisable = 'TwoFactorDisable',
    ResetPassword = 'ResetPassword'
}

/**
 * 
 * @export
 * @interface UserAgent
 */
export interface UserAgent {
    /**
     * 
     * @type {string}
     * @memberof UserAgent
     */
    family?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAgent
     */
    major?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAgent
     */
    minor?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserAgent
     */
    patch?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum UserCategory {
    Standart = 'Standart',
    Privileged = 'Privileged',
    Premium = 'Premium'
}

/**
 * 
 * @export
 * @interface ValidatePinPostRequest
 */
export interface ValidatePinPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatePinPostRequest
     */
    pinCode: string;
}
/**
 * 
 * @export
 * @interface VerificationResource
 */
export interface VerificationResource {
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    sid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    serviceSid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    accountSid?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    to?: string | null;
    /**
     * 
     * @type {object}
     * @memberof VerificationResource
     */
    channel?: object;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    status?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof VerificationResource
     */
    valid?: boolean | null;
    /**
     * 
     * @type {any}
     * @memberof VerificationResource
     */
    lookup?: any | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    amount?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    payee?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof VerificationResource
     */
    sendCodeAttempts?: Array<any> | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    dateCreated?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    dateUpdated?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VerificationResource
     */
    url?: string | null;
}
/**
 * 
 * @export
 * @interface VerifyFaceData
 */
export interface VerifyFaceData {
    /**
     * 
     * @type {string}
     * @memberof VerifyFaceData
     */
    faceId1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VerifyFaceData
     */
    faceId2?: string | null;
}
/**
 * 
 * @export
 * @interface VerifyResult
 */
export interface VerifyResult {
    /**
     * 
     * @type {boolean}
     * @memberof VerifyResult
     */
    isIdentical?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VerifyResult
     */
    confidence?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum WithdrawErrorCode {
    InvalidCurrency = 'InvalidCurrency',
    InvalidAmount = 'InvalidAmount',
    InvalidAddress = 'InvalidAddress',
    TwoStepRequired = 'TwoStepRequired',
    TwoStepFailed = 'TwoStepFailed'
}


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoinTokenAddRequest} [coinTokenAddRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminAddcointokenPost: async (coinTokenAddRequest?: CoinTokenAddRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Admin/addcointoken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof coinTokenAddRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(coinTokenAddRequest !== undefined ? coinTokenAddRequest : {})
                : (coinTokenAddRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminGetuserdataPost: async (email?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Admin/getuserdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminGetusertradedataPost: async (email?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Admin/getusertradedata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminSearchuserGet: async (searchString?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Admin/searchuser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {UserAdminCommand} [command] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminUsercommandPost: async (email?: string, command?: UserAdminCommand, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Admin/usercommand`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (command !== undefined) {
                localVarQueryParameter['command'] = command;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CoinTokenAddRequest} [coinTokenAddRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminAddcointokenPost(coinTokenAddRequest?: CoinTokenAddRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoCurrency>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).apiAdminAddcointokenPost(coinTokenAddRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminGetuserdataPost(email?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicationUser>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).apiAdminGetuserdataPost(email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminGetusertradedataPost(email?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TradeData>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).apiAdminGetusertradedataPost(email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminSearchuserGet(searchString?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).apiAdminSearchuserGet(searchString, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [email] 
         * @param {UserAdminCommand} [command] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAdminUsercommandPost(email?: string, command?: UserAdminCommand, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await AdminApiAxiosParamCreator(configuration).apiAdminUsercommandPost(email, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CoinTokenAddRequest} [coinTokenAddRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminAddcointokenPost(coinTokenAddRequest?: CoinTokenAddRequest, options?: any): AxiosPromise<CryptoCurrency> {
            return AdminApiFp(configuration).apiAdminAddcointokenPost(coinTokenAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminGetuserdataPost(email?: string, options?: any): AxiosPromise<ApplicationUser> {
            return AdminApiFp(configuration).apiAdminGetuserdataPost(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminGetusertradedataPost(email?: string, options?: any): AxiosPromise<TradeData> {
            return AdminApiFp(configuration).apiAdminGetusertradedataPost(email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [searchString] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminSearchuserGet(searchString?: string, options?: any): AxiosPromise<Array<string>> {
            return AdminApiFp(configuration).apiAdminSearchuserGet(searchString, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [email] 
         * @param {UserAdminCommand} [command] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAdminUsercommandPost(email?: string, command?: UserAdminCommand, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return AdminApiFp(configuration).apiAdminUsercommandPost(email, command, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {CoinTokenAddRequest} [coinTokenAddRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiAdminAddcointokenPost(coinTokenAddRequest?: CoinTokenAddRequest, options?: any) {
        return AdminApiFp(this.configuration).apiAdminAddcointokenPost(coinTokenAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiAdminGetuserdataPost(email?: string, options?: any) {
        return AdminApiFp(this.configuration).apiAdminGetuserdataPost(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiAdminGetusertradedataPost(email?: string, options?: any) {
        return AdminApiFp(this.configuration).apiAdminGetusertradedataPost(email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [searchString] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiAdminSearchuserGet(searchString?: string, options?: any) {
        return AdminApiFp(this.configuration).apiAdminSearchuserGet(searchString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [email] 
     * @param {UserAdminCommand} [command] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public apiAdminUsercommandPost(email?: string, command?: UserAdminCommand, options?: any) {
        return AdminApiFp(this.configuration).apiAdminUsercommandPost(email, command, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApplicationApi - axios parameter creator
 * @export
 */
export const ApplicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationDisableGoogle2stepPost: async (enableDisable2Fa?: EnableDisable2Fa, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/DisableGoogle2step`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof enableDisable2Fa !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(enableDisable2Fa !== undefined ? enableDisable2Fa : {})
                : (enableDisable2Fa || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationEnableGoogle2stepPost: async (enableDisable2Fa?: EnableDisable2Fa, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/EnableGoogle2step`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof enableDisable2Fa !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(enableDisable2Fa !== undefined ? enableDisable2Fa : {})
                : (enableDisable2Fa || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationPackagePost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/package`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationProcessFaceImagePost: async (processFaceImageRequest?: ProcessFaceImageRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/ProcessFaceImage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof processFaceImageRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(processFaceImageRequest !== undefined ? processFaceImageRequest : {})
                : (processFaceImageRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationProcessPassportImagePost: async (processFaceImageRequest?: ProcessFaceImageRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/ProcessPassportImage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof processFaceImageRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(processFaceImageRequest !== undefined ? processFaceImageRequest : {})
                : (processFaceImageRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationPublicKeyPut: async (updatePublicKeyRequest?: UpdatePublicKeyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/publicKey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof updatePublicKeyRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(updatePublicKeyRequest !== undefined ? updatePublicKeyRequest : {})
                : (updatePublicKeyRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationRatesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RestorePinPostRequest} [restorePinPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationRestorePinPost: async (restorePinPostRequest?: RestorePinPostRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/RestorePin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof restorePinPostRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(restorePinPostRequest !== undefined ? restorePinPostRequest : {})
                : (restorePinPostRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PinCodeRequestModel} [pinCodeRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationSetpinPut: async (pinCodeRequestModel?: PinCodeRequestModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/setpin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof pinCodeRequestModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(pinCodeRequestModel !== undefined ? pinCodeRequestModel : {})
                : (pinCodeRequestModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetPushTokenRequest} [setPushTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationSetpushtokenPost: async (setPushTokenRequest?: SetPushTokenRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/setpushtoken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof setPushTokenRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(setPushTokenRequest !== undefined ? setPushTokenRequest : {})
                : (setPushTokenRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationTestGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ValidatePinPostRequest} [validatePinPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationValidatePinPost: async (validatePinPostRequest?: ValidatePinPostRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/validatePin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof validatePinPostRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(validatePinPostRequest !== undefined ? validatePinPostRequest : {})
                : (validatePinPostRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyFaceData} [verifyFaceData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationVerifyfacesPost: async (verifyFaceData?: VerifyFaceData, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Application/verifyfaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof verifyFaceData !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(verifyFaceData !== undefined ? verifyFaceData : {})
                : (verifyFaceData || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationDisableGoogle2stepPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationDisableGoogle2stepPost(enableDisable2Fa, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationEnableGoogle2stepPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationEnableGoogle2stepPost(enableDisable2Fa, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationPackagePost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationPackagePost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationProcessFaceImagePost(processFaceImageRequest?: ProcessFaceImageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationProcessFaceImagePost(processFaceImageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationProcessPassportImagePost(processFaceImageRequest?: ProcessFaceImageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationProcessPassportImagePost(processFaceImageRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationPublicKeyPut(updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationPublicKeyPut(updatePublicKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationRatesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rate>>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationRatesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {RestorePinPostRequest} [restorePinPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationRestorePinPost(restorePinPostRequest?: RestorePinPostRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationRestorePinPost(restorePinPostRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PinCodeRequestModel} [pinCodeRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationSetpinPut(pinCodeRequestModel?: PinCodeRequestModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationSetpinPut(pinCodeRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SetPushTokenRequest} [setPushTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationSetpushtokenPost(setPushTokenRequest?: SetPushTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationSetpushtokenPost(setPushTokenRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationTestGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationTestGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ValidatePinPostRequest} [validatePinPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationValidatePinPost(validatePinPostRequest?: ValidatePinPostRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationValidatePinPost(validatePinPostRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {VerifyFaceData} [verifyFaceData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiApplicationVerifyfacesPost(verifyFaceData?: VerifyFaceData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyResult>> {
            const localVarAxiosArgs = await ApplicationApiAxiosParamCreator(configuration).apiApplicationVerifyfacesPost(verifyFaceData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationDisableGoogle2stepPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): AxiosPromise<void> {
            return ApplicationApiFp(configuration).apiApplicationDisableGoogle2stepPost(enableDisable2Fa, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {EnableDisable2Fa} [enableDisable2Fa] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationEnableGoogle2stepPost(enableDisable2Fa?: EnableDisable2Fa, options?: any): AxiosPromise<void> {
            return ApplicationApiFp(configuration).apiApplicationEnableGoogle2stepPost(enableDisable2Fa, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationPackagePost(options?: any): AxiosPromise<void> {
            return ApplicationApiFp(configuration).apiApplicationPackagePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationProcessFaceImagePost(processFaceImageRequest?: ProcessFaceImageRequest, options?: any): AxiosPromise<string> {
            return ApplicationApiFp(configuration).apiApplicationProcessFaceImagePost(processFaceImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationProcessPassportImagePost(processFaceImageRequest?: ProcessFaceImageRequest, options?: any): AxiosPromise<string> {
            return ApplicationApiFp(configuration).apiApplicationProcessPassportImagePost(processFaceImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationPublicKeyPut(updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return ApplicationApiFp(configuration).apiApplicationPublicKeyPut(updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationRatesGet(options?: any): AxiosPromise<Array<Rate>> {
            return ApplicationApiFp(configuration).apiApplicationRatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RestorePinPostRequest} [restorePinPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationRestorePinPost(restorePinPostRequest?: RestorePinPostRequest, options?: any): AxiosPromise<void> {
            return ApplicationApiFp(configuration).apiApplicationRestorePinPost(restorePinPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PinCodeRequestModel} [pinCodeRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationSetpinPut(pinCodeRequestModel?: PinCodeRequestModel, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return ApplicationApiFp(configuration).apiApplicationSetpinPut(pinCodeRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetPushTokenRequest} [setPushTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationSetpushtokenPost(setPushTokenRequest?: SetPushTokenRequest, options?: any): AxiosPromise<void> {
            return ApplicationApiFp(configuration).apiApplicationSetpushtokenPost(setPushTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationTestGet(options?: any): AxiosPromise<void> {
            return ApplicationApiFp(configuration).apiApplicationTestGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValidatePinPostRequest} [validatePinPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationValidatePinPost(validatePinPostRequest?: ValidatePinPostRequest, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return ApplicationApiFp(configuration).apiApplicationValidatePinPost(validatePinPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyFaceData} [verifyFaceData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiApplicationVerifyfacesPost(verifyFaceData?: VerifyFaceData, options?: any): AxiosPromise<VerifyResult> {
            return ApplicationApiFp(configuration).apiApplicationVerifyfacesPost(verifyFaceData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI {
    /**
     * 
     * @param {EnableDisable2Fa} [enableDisable2Fa] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationDisableGoogle2stepPost(enableDisable2Fa?: EnableDisable2Fa, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationDisableGoogle2stepPost(enableDisable2Fa, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EnableDisable2Fa} [enableDisable2Fa] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationEnableGoogle2stepPost(enableDisable2Fa?: EnableDisable2Fa, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationEnableGoogle2stepPost(enableDisable2Fa, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationPackagePost(options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationPackagePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationProcessFaceImagePost(processFaceImageRequest?: ProcessFaceImageRequest, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationProcessFaceImagePost(processFaceImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProcessFaceImageRequest} [processFaceImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationProcessPassportImagePost(processFaceImageRequest?: ProcessFaceImageRequest, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationProcessPassportImagePost(processFaceImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdatePublicKeyRequest} [updatePublicKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationPublicKeyPut(updatePublicKeyRequest?: UpdatePublicKeyRequest, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationPublicKeyPut(updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationRatesGet(options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationRatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RestorePinPostRequest} [restorePinPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationRestorePinPost(restorePinPostRequest?: RestorePinPostRequest, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationRestorePinPost(restorePinPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PinCodeRequestModel} [pinCodeRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationSetpinPut(pinCodeRequestModel?: PinCodeRequestModel, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationSetpinPut(pinCodeRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetPushTokenRequest} [setPushTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationSetpushtokenPost(setPushTokenRequest?: SetPushTokenRequest, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationSetpushtokenPost(setPushTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationTestGet(options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationTestGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValidatePinPostRequest} [validatePinPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationValidatePinPost(validatePinPostRequest?: ValidatePinPostRequest, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationValidatePinPost(validatePinPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyFaceData} [verifyFaceData] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public apiApplicationVerifyfacesPost(verifyFaceData?: VerifyFaceData, options?: any) {
        return ApplicationApiFp(this.configuration).apiApplicationVerifyfacesPost(verifyFaceData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BalanceApi - axios parameter creator
 * @export
 */
export const BalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceCurrencyGet: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling apiBalanceCurrencyGet.');
            }
            const localVarPath = `/api/Balance/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceDepositCurrencyAddressGet: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling apiBalanceDepositCurrencyAddressGet.');
            }
            const localVarPath = `/api/Balance/deposit/{currency}/address`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceDepositCurrencyAddressPost: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling apiBalanceDepositCurrencyAddressPost.');
            }
            const localVarPath = `/api/Balance/deposit/{currency}/address`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceWithdrawCurrencyPageGet: async (currency: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling apiBalanceWithdrawCurrencyPageGet.');
            }
            const localVarPath = `/api/Balance/withdraw/{currency}/page`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {PostWithdrawRequest} [postWithdrawRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceWithdrawCurrencyPost: async (currency: string, postWithdrawRequest?: PostWithdrawRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currency' is not null or undefined
            if (currency === null || currency === undefined) {
                throw new RequiredError('currency','Required parameter currency was null or undefined when calling apiBalanceWithdrawCurrencyPost.');
            }
            const localVarPath = `/api/Balance/withdraw/{currency}`
                .replace(`{${"currency"}}`, encodeURIComponent(String(currency)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postWithdrawRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postWithdrawRequest !== undefined ? postWithdrawRequest : {})
                : (postWithdrawRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceApi - functional programming interface
 * @export
 */
export const BalanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBalanceCurrencyGet(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceRequestModel>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).apiBalanceCurrencyGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBalanceDepositCurrencyAddressGet(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressResponse>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).apiBalanceDepositCurrencyAddressGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBalanceDepositCurrencyAddressPost(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateAddressResult>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).apiBalanceDepositCurrencyAddressPost(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBalanceGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalancesListResponse>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).apiBalanceGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBalanceWithdrawCurrencyPageGet(currency: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWithdrawResponse>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).apiBalanceWithdrawCurrencyPageGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} currency 
         * @param {PostWithdrawRequest} [postWithdrawRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBalanceWithdrawCurrencyPost(currency: string, postWithdrawRequest?: PostWithdrawRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostWithdrawRequestResult>> {
            const localVarAxiosArgs = await BalanceApiAxiosParamCreator(configuration).apiBalanceWithdrawCurrencyPost(currency, postWithdrawRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BalanceApi - factory interface
 * @export
 */
export const BalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceCurrencyGet(currency: string, options?: any): AxiosPromise<GetBalanceRequestModel> {
            return BalanceApiFp(configuration).apiBalanceCurrencyGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceDepositCurrencyAddressGet(currency: string, options?: any): AxiosPromise<GetAddressResponse> {
            return BalanceApiFp(configuration).apiBalanceDepositCurrencyAddressGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceDepositCurrencyAddressPost(currency: string, options?: any): AxiosPromise<GenerateAddressResult> {
            return BalanceApiFp(configuration).apiBalanceDepositCurrencyAddressPost(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceGet(options?: any): AxiosPromise<GetBalancesListResponse> {
            return BalanceApiFp(configuration).apiBalanceGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceWithdrawCurrencyPageGet(currency: string, options?: any): AxiosPromise<GetWithdrawResponse> {
            return BalanceApiFp(configuration).apiBalanceWithdrawCurrencyPageGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} currency 
         * @param {PostWithdrawRequest} [postWithdrawRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBalanceWithdrawCurrencyPost(currency: string, postWithdrawRequest?: PostWithdrawRequest, options?: any): AxiosPromise<PostWithdrawRequestResult> {
            return BalanceApiFp(configuration).apiBalanceWithdrawCurrencyPost(currency, postWithdrawRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export class BalanceApi extends BaseAPI {
    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiBalanceCurrencyGet(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).apiBalanceCurrencyGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiBalanceDepositCurrencyAddressGet(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).apiBalanceDepositCurrencyAddressGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiBalanceDepositCurrencyAddressPost(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).apiBalanceDepositCurrencyAddressPost(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiBalanceGet(options?: any) {
        return BalanceApiFp(this.configuration).apiBalanceGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiBalanceWithdrawCurrencyPageGet(currency: string, options?: any) {
        return BalanceApiFp(this.configuration).apiBalanceWithdrawCurrencyPageGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} currency 
     * @param {PostWithdrawRequest} [postWithdrawRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiBalanceWithdrawCurrencyPost(currency: string, postWithdrawRequest?: PostWithdrawRequest, options?: any) {
        return BalanceApiFp(this.configuration).apiBalanceWithdrawCurrencyPost(currency, postWithdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GuardApi - axios parameter creator
 * @export
 */
export const GuardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardGetAccessTokensGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Guard/GetAccessTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardPrecheckLogoutPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Guard/PrecheckLogout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestSettingsTokenResponseRequestModel} [requestSettingsTokenResponseRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardRequestSettingsTokenPost: async (requestSettingsTokenResponseRequestModel?: RequestSettingsTokenResponseRequestModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Guard/RequestSettingsToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof requestSettingsTokenResponseRequestModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(requestSettingsTokenResponseRequestModel !== undefined ? requestSettingsTokenResponseRequestModel : {})
                : (requestSettingsTokenResponseRequestModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RevokeTokenByIdRequestModel} [revokeTokenByIdRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardRevokeTokenByIdPost: async (revokeTokenByIdRequestModel?: RevokeTokenByIdRequestModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Guard/RevokeTokenById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof revokeTokenByIdRequestModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(revokeTokenByIdRequestModel !== undefined ? revokeTokenByIdRequestModel : {})
                : (revokeTokenByIdRequestModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardRevokeTokenPost: async (body?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Guard/RevokeToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuardApi - functional programming interface
 * @export
 */
export const GuardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGuardGetAccessTokensGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetAccessTokensResponse>>> {
            const localVarAxiosArgs = await GuardApiAxiosParamCreator(configuration).apiGuardGetAccessTokensGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGuardPrecheckLogoutPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrecheckLogoutResult>> {
            const localVarAxiosArgs = await GuardApiAxiosParamCreator(configuration).apiGuardPrecheckLogoutPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {RequestSettingsTokenResponseRequestModel} [requestSettingsTokenResponseRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGuardRequestSettingsTokenPost(requestSettingsTokenResponseRequestModel?: RequestSettingsTokenResponseRequestModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestSettingsTokenResponseModel>> {
            const localVarAxiosArgs = await GuardApiAxiosParamCreator(configuration).apiGuardRequestSettingsTokenPost(requestSettingsTokenResponseRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {RevokeTokenByIdRequestModel} [revokeTokenByIdRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGuardRevokeTokenByIdPost(revokeTokenByIdRequestModel?: RevokeTokenByIdRequestModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GuardApiAxiosParamCreator(configuration).apiGuardRevokeTokenByIdPost(revokeTokenByIdRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGuardRevokeTokenPost(body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GuardApiAxiosParamCreator(configuration).apiGuardRevokeTokenPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GuardApi - factory interface
 * @export
 */
export const GuardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardGetAccessTokensGet(options?: any): AxiosPromise<Array<GetAccessTokensResponse>> {
            return GuardApiFp(configuration).apiGuardGetAccessTokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardPrecheckLogoutPost(options?: any): AxiosPromise<PrecheckLogoutResult> {
            return GuardApiFp(configuration).apiGuardPrecheckLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestSettingsTokenResponseRequestModel} [requestSettingsTokenResponseRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardRequestSettingsTokenPost(requestSettingsTokenResponseRequestModel?: RequestSettingsTokenResponseRequestModel, options?: any): AxiosPromise<RequestSettingsTokenResponseModel> {
            return GuardApiFp(configuration).apiGuardRequestSettingsTokenPost(requestSettingsTokenResponseRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RevokeTokenByIdRequestModel} [revokeTokenByIdRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardRevokeTokenByIdPost(revokeTokenByIdRequestModel?: RevokeTokenByIdRequestModel, options?: any): AxiosPromise<void> {
            return GuardApiFp(configuration).apiGuardRevokeTokenByIdPost(revokeTokenByIdRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGuardRevokeTokenPost(body?: string, options?: any): AxiosPromise<void> {
            return GuardApiFp(configuration).apiGuardRevokeTokenPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuardApi - object-oriented interface
 * @export
 * @class GuardApi
 * @extends {BaseAPI}
 */
export class GuardApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardApi
     */
    public apiGuardGetAccessTokensGet(options?: any) {
        return GuardApiFp(this.configuration).apiGuardGetAccessTokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardApi
     */
    public apiGuardPrecheckLogoutPost(options?: any) {
        return GuardApiFp(this.configuration).apiGuardPrecheckLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestSettingsTokenResponseRequestModel} [requestSettingsTokenResponseRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardApi
     */
    public apiGuardRequestSettingsTokenPost(requestSettingsTokenResponseRequestModel?: RequestSettingsTokenResponseRequestModel, options?: any) {
        return GuardApiFp(this.configuration).apiGuardRequestSettingsTokenPost(requestSettingsTokenResponseRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RevokeTokenByIdRequestModel} [revokeTokenByIdRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardApi
     */
    public apiGuardRevokeTokenByIdPost(revokeTokenByIdRequestModel?: RevokeTokenByIdRequestModel, options?: any) {
        return GuardApiFp(this.configuration).apiGuardRevokeTokenByIdPost(revokeTokenByIdRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuardApi
     */
    public apiGuardRevokeTokenPost(body?: string, options?: any) {
        return GuardApiFp(this.configuration).apiGuardRevokeTokenPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHealthTickGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Health/tick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServerLocation} [location] 
         * @param {number} [elapsed] 
         * @param {number} [timeStamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHealthTockGet: async (location?: ServerLocation, elapsed?: number, timeStamp?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Health/tock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (elapsed !== undefined) {
                localVarQueryParameter['elapsed'] = elapsed;
            }

            if (timeStamp !== undefined) {
                localVarQueryParameter['timeStamp'] = timeStamp;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHealthTickGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTickeAsyncResponse>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).apiHealthTickGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ServerLocation} [location] 
         * @param {number} [elapsed] 
         * @param {number} [timeStamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiHealthTockGet(location?: ServerLocation, elapsed?: number, timeStamp?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).apiHealthTockGet(location, elapsed, timeStamp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHealthTickGet(options?: any): AxiosPromise<GetTickeAsyncResponse> {
            return HealthApiFp(configuration).apiHealthTickGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerLocation} [location] 
         * @param {number} [elapsed] 
         * @param {number} [timeStamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiHealthTockGet(location?: ServerLocation, elapsed?: number, timeStamp?: number, options?: any): AxiosPromise<void> {
            return HealthApiFp(configuration).apiHealthTockGet(location, elapsed, timeStamp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiHealthTickGet(options?: any) {
        return HealthApiFp(this.configuration).apiHealthTickGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServerLocation} [location] 
     * @param {number} [elapsed] 
     * @param {number} [timeStamp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public apiHealthTockGet(location?: ServerLocation, elapsed?: number, timeStamp?: number, options?: any) {
        return HealthApiFp(this.configuration).apiHealthTockGet(location, elapsed, timeStamp, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MarketsApi - axios parameter creator
 * @export
 */
export const MarketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsCurrenciesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsCurrencyInfoGet: async (currency?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/currencyInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fingerprint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsGet: async (fingerprint?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsHistoryGet: async (pair?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsOrderbookGet: async (pair?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/orderbook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsTickersGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Markets/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketsApi - functional programming interface
 * @export
 */
export const MarketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsCurrenciesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetApiMarketsCurrenciesResponse>>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsCurrenciesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsCurrencyInfoGet(currency?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CryptoCurrency>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsCurrencyInfoGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [fingerprint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsGet(fingerprint?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMarketsResponse>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsGet(fingerprint, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsHistoryGet(pair?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTradeHistoryResponse>>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsHistoryGet(pair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsOrderbookGet(pair?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrdersGetViewModel>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsOrderbookGet(pair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMarketsTickersGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTickersResponse>> {
            const localVarAxiosArgs = await MarketsApiAxiosParamCreator(configuration).apiMarketsTickersGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MarketsApi - factory interface
 * @export
 */
export const MarketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsCurrenciesGet(options?: any): AxiosPromise<Array<GetApiMarketsCurrenciesResponse>> {
            return MarketsApiFp(configuration).apiMarketsCurrenciesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsCurrencyInfoGet(currency?: string, options?: any): AxiosPromise<CryptoCurrency> {
            return MarketsApiFp(configuration).apiMarketsCurrencyInfoGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fingerprint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsGet(fingerprint?: string, options?: any): AxiosPromise<GetMarketsResponse> {
            return MarketsApiFp(configuration).apiMarketsGet(fingerprint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsHistoryGet(pair?: string, options?: any): AxiosPromise<Array<GetTradeHistoryResponse>> {
            return MarketsApiFp(configuration).apiMarketsHistoryGet(pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsOrderbookGet(pair?: string, options?: any): AxiosPromise<OrdersGetViewModel> {
            return MarketsApiFp(configuration).apiMarketsOrderbookGet(pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMarketsTickersGet(options?: any): AxiosPromise<GetTickersResponse> {
            return MarketsApiFp(configuration).apiMarketsTickersGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketsApi - object-oriented interface
 * @export
 * @class MarketsApi
 * @extends {BaseAPI}
 */
export class MarketsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsCurrenciesGet(options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsCurrenciesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsCurrencyInfoGet(currency?: string, options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsCurrencyInfoGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fingerprint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsGet(fingerprint?: string, options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsGet(fingerprint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsHistoryGet(pair?: string, options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsHistoryGet(pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsOrderbookGet(pair?: string, options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsOrderbookGet(pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketsApi
     */
    public apiMarketsTickersGet(options?: any) {
        return MarketsApiFp(this.configuration).apiMarketsTickersGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [alertId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsPricealertDelete: async (alertId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Notifications/pricealert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (alertId !== undefined) {
                localVarQueryParameter['alertId'] = alertId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pairName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsPricealertGet: async (pairName?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Notifications/pricealert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (pairName !== undefined) {
                localVarQueryParameter['pairName'] = pairName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetPriceAlertRequestModel} [setPriceAlertRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsPricealertPost: async (setPriceAlertRequestModel?: SetPriceAlertRequestModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Notifications/pricealert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof setPriceAlertRequestModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(setPriceAlertRequestModel !== undefined ? setPriceAlertRequestModel : {})
                : (setPriceAlertRequestModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [alertId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsPricealertDelete(alertId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).apiNotificationsPricealertDelete(alertId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pairName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsPricealertGet(pairName?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PriceAlert>>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).apiNotificationsPricealertGet(pairName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SetPriceAlertRequestModel} [setPriceAlertRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiNotificationsPricealertPost(setPriceAlertRequestModel?: SetPriceAlertRequestModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetPriceAlertResponseModel>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).apiNotificationsPricealertPost(setPriceAlertRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [alertId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsPricealertDelete(alertId?: string, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return NotificationsApiFp(configuration).apiNotificationsPricealertDelete(alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pairName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsPricealertGet(pairName?: string, options?: any): AxiosPromise<Array<PriceAlert>> {
            return NotificationsApiFp(configuration).apiNotificationsPricealertGet(pairName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetPriceAlertRequestModel} [setPriceAlertRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiNotificationsPricealertPost(setPriceAlertRequestModel?: SetPriceAlertRequestModel, options?: any): AxiosPromise<SetPriceAlertResponseModel> {
            return NotificationsApiFp(configuration).apiNotificationsPricealertPost(setPriceAlertRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {string} [alertId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsPricealertDelete(alertId?: string, options?: any) {
        return NotificationsApiFp(this.configuration).apiNotificationsPricealertDelete(alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pairName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsPricealertGet(pairName?: string, options?: any) {
        return NotificationsApiFp(this.configuration).apiNotificationsPricealertGet(pairName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetPriceAlertRequestModel} [setPriceAlertRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public apiNotificationsPricealertPost(setPriceAlertRequestModel?: SetPriceAlertRequestModel, options?: any) {
        return NotificationsApiFp(this.configuration).apiNotificationsPricealertPost(setPriceAlertRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [orderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersCancelPost: async (orderId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Orders/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pairName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersPairNameGet: async (pairName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pairName' is not null or undefined
            if (pairName === null || pairName === undefined) {
                throw new RequiredError('pairName','Required parameter pairName was null or undefined when calling apiOrdersPairNameGet.');
            }
            const localVarPath = `/api/Orders/{pairName}`
                .replace(`{${"pairName"}}`, encodeURIComponent(String(pairName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostOrdersRequest} [postOrdersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersPost: async (postOrdersRequest?: PostOrdersRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postOrdersRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postOrdersRequest !== undefined ? postOrdersRequest : {})
                : (postOrdersRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [orderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersCancelPost(orderId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCancelResult>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).apiOrdersCancelPost(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} pairName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersPairNameGet(pairName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).apiOrdersPairNameGet(pairName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostOrdersRequest} [postOrdersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOrdersPost(postOrdersRequest?: PostOrdersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCreateResult>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).apiOrdersPost(postOrdersRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [orderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersCancelPost(orderId?: string, options?: any): AxiosPromise<OrderCancelResult> {
            return OrdersApiFp(configuration).apiOrdersCancelPost(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pairName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersPairNameGet(pairName: string, options?: any): AxiosPromise<void> {
            return OrdersApiFp(configuration).apiOrdersPairNameGet(pairName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostOrdersRequest} [postOrdersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOrdersPost(postOrdersRequest?: PostOrdersRequest, options?: any): AxiosPromise<OrderCreateResult> {
            return OrdersApiFp(configuration).apiOrdersPost(postOrdersRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @param {string} [orderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersCancelPost(orderId?: string, options?: any) {
        return OrdersApiFp(this.configuration).apiOrdersCancelPost(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} pairName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersPairNameGet(pairName: string, options?: any) {
        return OrdersApiFp(this.configuration).apiOrdersPairNameGet(pairName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostOrdersRequest} [postOrdersRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public apiOrdersPost(postOrdersRequest?: PostOrdersRequest, options?: any) {
        return OrdersApiFp(this.configuration).apiOrdersPost(postOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SignApi - axios parameter creator
 * @export
 */
export const SignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignAskForPermissionPost: async (askForPermissionRequestModel?: AskForPermissionRequestModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/AskForPermission`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof askForPermissionRequestModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(askForPermissionRequestModel !== undefined ? askForPermissionRequestModel : {})
                : (askForPermissionRequestModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignAskPermissionSignInPost: async (askForPermissionRequestModel?: AskForPermissionRequestModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/AskPermissionSignIn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof askForPermissionRequestModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(askForPermissionRequestModel !== undefined ? askForPermissionRequestModel : {})
                : (askForPermissionRequestModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [bitflexDeviceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignCheck2StepVerificationStatusGet: async (bitflexDeviceId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/Check2StepVerificationStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (bitflexDeviceId !== undefined) {
                localVarQueryParameter['bitflexDeviceId'] = bitflexDeviceId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostConfirmPermissionSignInRequest} [postConfirmPermissionSignInRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignConfirmPermissionSignInPost: async (postConfirmPermissionSignInRequest?: PostConfirmPermissionSignInRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/ConfirmPermissionSignIn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postConfirmPermissionSignInRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postConfirmPermissionSignInRequest !== undefined ? postConfirmPermissionSignInRequest : {})
                : (postConfirmPermissionSignInRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostConfirmRequest} [postConfirmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignConfirmemailPost: async (postConfirmRequest?: PostConfirmRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/confirmemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postConfirmRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postConfirmRequest !== undefined ? postConfirmRequest : {})
                : (postConfirmRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignGetPermissionDetailsGet: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/GetPermissionDetails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignIsAnyDeviceOnlinePost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/IsAnyDeviceOnline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostMobileConfirmationRequestModel} [postMobileConfirmationRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignMobileConfirmationRequestPost: async (postMobileConfirmationRequestModel?: PostMobileConfirmationRequestModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/MobileConfirmationRequest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postMobileConfirmationRequestModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postMobileConfirmationRequestModel !== undefined ? postMobileConfirmationRequestModel : {})
                : (postMobileConfirmationRequestModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostResetPasswordRequest} [postResetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignResetpasswordPost: async (postResetPasswordRequest?: PostResetPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/resetpassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postResetPasswordRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postResetPasswordRequest !== undefined ? postResetPasswordRequest : {})
                : (postResetPasswordRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostForgotPasswordRequest} [postForgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignRestorepasswordPost: async (postForgotPasswordRequest?: PostForgotPasswordRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/restorepassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postForgotPasswordRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postForgotPasswordRequest !== undefined ? postForgotPasswordRequest : {})
                : (postForgotPasswordRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangePasswordRequest} [changePasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSetnewpasswordPost: async (changePasswordRequest?: ChangePasswordRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/setnewpassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof changePasswordRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(changePasswordRequest !== undefined ? changePasswordRequest : {})
                : (changePasswordRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSigninGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostSignInRequest} [postSignInRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSigninPost: async (postSignInRequest?: PostSignInRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postSignInRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postSignInRequest !== undefined ? postSignInRequest : {})
                : (postSignInRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSignoutDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/signout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostSignUpRequest} [postSignUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSignupPost: async (postSignUpRequest?: PostSignUpRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Sign/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postSignUpRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postSignUpRequest !== undefined ? postSignUpRequest : {})
                : (postSignUpRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignApi - functional programming interface
 * @export
 */
export const SignApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignAskForPermissionPost(askForPermissionRequestModel?: AskForPermissionRequestModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignAskForPermissionPost(askForPermissionRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignAskPermissionSignInPost(askForPermissionRequestModel?: AskForPermissionRequestModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignAskPermissionSignInPost(askForPermissionRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [bitflexDeviceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignCheck2StepVerificationStatusGet(bitflexDeviceId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check2StepVerificationStatusResponse>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignCheck2StepVerificationStatusGet(bitflexDeviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostConfirmPermissionSignInRequest} [postConfirmPermissionSignInRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignConfirmPermissionSignInPost(postConfirmPermissionSignInRequest?: PostConfirmPermissionSignInRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignConfirmPermissionSignInPost(postConfirmPermissionSignInRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostConfirmRequest} [postConfirmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignConfirmemailPost(postConfirmRequest?: PostConfirmRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailConfirmationResult>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignConfirmemailPost(postConfirmRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignGetPermissionDetailsGet(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInPermissionModel>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignGetPermissionDetailsGet(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignIsAnyDeviceOnlinePost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignIsAnyDeviceOnlinePost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostMobileConfirmationRequestModel} [postMobileConfirmationRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignMobileConfirmationRequestPost(postMobileConfirmationRequestModel?: PostMobileConfirmationRequestModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignMobileConfirmationRequestPost(postMobileConfirmationRequestModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostResetPasswordRequest} [postResetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignResetpasswordPost(postResetPasswordRequest?: PostResetPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignResetpasswordPost(postResetPasswordRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostForgotPasswordRequest} [postForgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignRestorepasswordPost(postForgotPasswordRequest?: PostForgotPasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignRestorepasswordPost(postForgotPasswordRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ChangePasswordRequest} [changePasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignSetnewpasswordPost(changePasswordRequest?: ChangePasswordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignSetnewpasswordPost(changePasswordRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignSigninGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignSigninGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostSignInRequest} [postSignInRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignSigninPost(postSignInRequest?: PostSignInRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSignInResponse>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignSigninPost(postSignInRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignSignoutDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignSignoutDelete(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostSignUpRequest} [postSignUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSignSignupPost(postSignUpRequest?: PostSignUpRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostSignUpResponse>> {
            const localVarAxiosArgs = await SignApiAxiosParamCreator(configuration).apiSignSignupPost(postSignUpRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SignApi - factory interface
 * @export
 */
export const SignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignAskForPermissionPost(askForPermissionRequestModel?: AskForPermissionRequestModel, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return SignApiFp(configuration).apiSignAskForPermissionPost(askForPermissionRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignAskPermissionSignInPost(askForPermissionRequestModel?: AskForPermissionRequestModel, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return SignApiFp(configuration).apiSignAskPermissionSignInPost(askForPermissionRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [bitflexDeviceId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignCheck2StepVerificationStatusGet(bitflexDeviceId?: string, options?: any): AxiosPromise<Check2StepVerificationStatusResponse> {
            return SignApiFp(configuration).apiSignCheck2StepVerificationStatusGet(bitflexDeviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostConfirmPermissionSignInRequest} [postConfirmPermissionSignInRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignConfirmPermissionSignInPost(postConfirmPermissionSignInRequest?: PostConfirmPermissionSignInRequest, options?: any): AxiosPromise<void> {
            return SignApiFp(configuration).apiSignConfirmPermissionSignInPost(postConfirmPermissionSignInRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostConfirmRequest} [postConfirmRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignConfirmemailPost(postConfirmRequest?: PostConfirmRequest, options?: any): AxiosPromise<EmailConfirmationResult> {
            return SignApiFp(configuration).apiSignConfirmemailPost(postConfirmRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignGetPermissionDetailsGet(id?: string, options?: any): AxiosPromise<SignInPermissionModel> {
            return SignApiFp(configuration).apiSignGetPermissionDetailsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignIsAnyDeviceOnlinePost(options?: any): AxiosPromise<void> {
            return SignApiFp(configuration).apiSignIsAnyDeviceOnlinePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostMobileConfirmationRequestModel} [postMobileConfirmationRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignMobileConfirmationRequestPost(postMobileConfirmationRequestModel?: PostMobileConfirmationRequestModel, options?: any): AxiosPromise<void> {
            return SignApiFp(configuration).apiSignMobileConfirmationRequestPost(postMobileConfirmationRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostResetPasswordRequest} [postResetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignResetpasswordPost(postResetPasswordRequest?: PostResetPasswordRequest, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return SignApiFp(configuration).apiSignResetpasswordPost(postResetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostForgotPasswordRequest} [postForgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignRestorepasswordPost(postForgotPasswordRequest?: PostForgotPasswordRequest, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return SignApiFp(configuration).apiSignRestorepasswordPost(postForgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangePasswordRequest} [changePasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSetnewpasswordPost(changePasswordRequest?: ChangePasswordRequest, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return SignApiFp(configuration).apiSignSetnewpasswordPost(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSigninGet(options?: any): AxiosPromise<void> {
            return SignApiFp(configuration).apiSignSigninGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostSignInRequest} [postSignInRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSigninPost(postSignInRequest?: PostSignInRequest, options?: any): AxiosPromise<PostSignInResponse> {
            return SignApiFp(configuration).apiSignSigninPost(postSignInRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSignoutDelete(options?: any): AxiosPromise<void> {
            return SignApiFp(configuration).apiSignSignoutDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostSignUpRequest} [postSignUpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSignSignupPost(postSignUpRequest?: PostSignUpRequest, options?: any): AxiosPromise<PostSignUpResponse> {
            return SignApiFp(configuration).apiSignSignupPost(postSignUpRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignApi - object-oriented interface
 * @export
 * @class SignApi
 * @extends {BaseAPI}
 */
export class SignApi extends BaseAPI {
    /**
     * 
     * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignAskForPermissionPost(askForPermissionRequestModel?: AskForPermissionRequestModel, options?: any) {
        return SignApiFp(this.configuration).apiSignAskForPermissionPost(askForPermissionRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AskForPermissionRequestModel} [askForPermissionRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignAskPermissionSignInPost(askForPermissionRequestModel?: AskForPermissionRequestModel, options?: any) {
        return SignApiFp(this.configuration).apiSignAskPermissionSignInPost(askForPermissionRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [bitflexDeviceId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignCheck2StepVerificationStatusGet(bitflexDeviceId?: string, options?: any) {
        return SignApiFp(this.configuration).apiSignCheck2StepVerificationStatusGet(bitflexDeviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostConfirmPermissionSignInRequest} [postConfirmPermissionSignInRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignConfirmPermissionSignInPost(postConfirmPermissionSignInRequest?: PostConfirmPermissionSignInRequest, options?: any) {
        return SignApiFp(this.configuration).apiSignConfirmPermissionSignInPost(postConfirmPermissionSignInRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostConfirmRequest} [postConfirmRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignConfirmemailPost(postConfirmRequest?: PostConfirmRequest, options?: any) {
        return SignApiFp(this.configuration).apiSignConfirmemailPost(postConfirmRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignGetPermissionDetailsGet(id?: string, options?: any) {
        return SignApiFp(this.configuration).apiSignGetPermissionDetailsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignIsAnyDeviceOnlinePost(options?: any) {
        return SignApiFp(this.configuration).apiSignIsAnyDeviceOnlinePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostMobileConfirmationRequestModel} [postMobileConfirmationRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignMobileConfirmationRequestPost(postMobileConfirmationRequestModel?: PostMobileConfirmationRequestModel, options?: any) {
        return SignApiFp(this.configuration).apiSignMobileConfirmationRequestPost(postMobileConfirmationRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostResetPasswordRequest} [postResetPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignResetpasswordPost(postResetPasswordRequest?: PostResetPasswordRequest, options?: any) {
        return SignApiFp(this.configuration).apiSignResetpasswordPost(postResetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostForgotPasswordRequest} [postForgotPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignRestorepasswordPost(postForgotPasswordRequest?: PostForgotPasswordRequest, options?: any) {
        return SignApiFp(this.configuration).apiSignRestorepasswordPost(postForgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangePasswordRequest} [changePasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignSetnewpasswordPost(changePasswordRequest?: ChangePasswordRequest, options?: any) {
        return SignApiFp(this.configuration).apiSignSetnewpasswordPost(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignSigninGet(options?: any) {
        return SignApiFp(this.configuration).apiSignSigninGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostSignInRequest} [postSignInRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignSigninPost(postSignInRequest?: PostSignInRequest, options?: any) {
        return SignApiFp(this.configuration).apiSignSigninPost(postSignInRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignSignoutDelete(options?: any) {
        return SignApiFp(this.configuration).apiSignSignoutDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostSignUpRequest} [postSignUpRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignApi
     */
    public apiSignSignupPost(postSignUpRequest?: PostSignUpRequest, options?: any) {
        return SignApiFp(this.configuration).apiSignSignupPost(postSignUpRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StaticPagesApi - axios parameter creator
 * @export
 */
export const StaticPagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStaticPagesAffiliateGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/StaticPages/affiliate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStaticPagesStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/StaticPages/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaticPagesApi - functional programming interface
 * @export
 */
export const StaticPagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStaticPagesAffiliateGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StaticPagesApiAxiosParamCreator(configuration).apiStaticPagesAffiliateGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStaticPagesStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StaticPagesApiAxiosParamCreator(configuration).apiStaticPagesStatusGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StaticPagesApi - factory interface
 * @export
 */
export const StaticPagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStaticPagesAffiliateGet(options?: any): AxiosPromise<void> {
            return StaticPagesApiFp(configuration).apiStaticPagesAffiliateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStaticPagesStatusGet(options?: any): AxiosPromise<void> {
            return StaticPagesApiFp(configuration).apiStaticPagesStatusGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StaticPagesApi - object-oriented interface
 * @export
 * @class StaticPagesApi
 * @extends {BaseAPI}
 */
export class StaticPagesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticPagesApi
     */
    public apiStaticPagesAffiliateGet(options?: any) {
        return StaticPagesApiFp(this.configuration).apiStaticPagesAffiliateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticPagesApi
     */
    public apiStaticPagesStatusGet(options?: any) {
        return StaticPagesApiFp(this.configuration).apiStaticPagesStatusGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAffiliateGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/affiliate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAffiliatePost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/affiliate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [bfApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApikeysDelete: async (bfApiKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/apikeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (bfApiKey !== undefined) {
                localVarQueryParameter['bfApiKey'] = bfApiKey;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApikeysGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/apikeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateApiKeyRequest} [generateApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApikeysPost: async (generateApiKeyRequest?: GenerateApiKeyRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/apikeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof generateApiKeyRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(generateApiKeyRequest !== undefined ? generateApiKeyRequest : {})
                : (generateApiKeyRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceactionsGet: async (page?: number, size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/balanceactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalancesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceslistGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/balanceslist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDepositsGet: async (currency?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [gcode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDisableGoogleAuthenticatorDelete: async (gcode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/DisableGoogleAuthenticator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (gcode !== undefined) {
                localVarQueryParameter['gcode'] = gcode;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [backupCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDisableGoogleAuthenticatorWithBackupCodeDelete: async (backupCode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/DisableGoogleAuthenticatorWithBackupCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (backupCode !== undefined) {
                localVarQueryParameter['backupCode'] = backupCode;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FinishTier1VerificationModel} [finishTier1VerificationModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFinishTier1VerificationPost: async (finishTier1VerificationModel?: FinishTier1VerificationModel, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/FinishTier1Verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof finishTier1VerificationModel !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(finishTier1VerificationModel !== undefined ? finishTier1VerificationModel : {})
                : (finishTier1VerificationModel || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGenerateGoogleAuthenticatorSetupCodePost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/GenerateGoogleAuthenticatorSetupCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGetVerificationLevelGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/GetVerificationLevel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserOrdersGet: async (pair?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [phoneNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSetPhoneNumberPost: async (phoneNumber?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/SetPhoneNumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (phoneNumber !== undefined) {
                localVarQueryParameter['phoneNumber'] = phoneNumber;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [pairId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTradehistoryGet: async (pairId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/tradehistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (pairId !== undefined) {
                localVarQueryParameter['pairId'] = pairId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerificationsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/verifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerificationtypeGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/verificationtype`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [gcode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerifyGoogleAuthenticatorSetupCodePost: async (gcode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/VerifyGoogleAuthenticatorSetupCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (gcode !== undefined) {
                localVarQueryParameter['gcode'] = gcode;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PostVefirySms} [postVefirySms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerifyPhoneNumberPost: async (postVefirySms?: PostVefirySms, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/VerifyPhoneNumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof postVefirySms !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(postVefirySms !== undefined ? postVefirySms : {})
                : (postVefirySms || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserWithdrawalsGet: async (currency?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/User/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            // authentication X-BF-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-BF-API-KEY")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-BF-API-KEY"] = localVarApiKeyValue;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserAffiliateGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffiliateDataResponse>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserAffiliateGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserAffiliatePost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffiliateDataResponse>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserAffiliatePost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [bfApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApikeysDelete(bfApiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserApikeysDelete(bfApiKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApikeysGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserApikeysGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {GenerateApiKeyRequest} [generateApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserApikeysPost(generateApiKeyRequest?: GenerateApiKeyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserApikeysPost(generateApiKeyRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserBalanceactionsGet(page?: number, size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalanceActionsResponse>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserBalanceactionsGet(page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserBalancesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserBalancesGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserBalanceslistGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBalancesListResponse>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserBalanceslistGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserDepositsGet(currency?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiGetDepositsWitdrawals>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserDepositsGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [gcode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserDisableGoogleAuthenticatorDelete(gcode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserDisableGoogleAuthenticatorDelete(gcode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [backupCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserDisableGoogleAuthenticatorWithBackupCodeDelete(backupCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserDisableGoogleAuthenticatorWithBackupCodeDelete(backupCode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {FinishTier1VerificationModel} [finishTier1VerificationModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFinishTier1VerificationPost(finishTier1VerificationModel?: FinishTier1VerificationModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserFinishTier1VerificationPost(finishTier1VerificationModel, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGenerateGoogleAuthenticatorSetupCodePost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetupCode>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserGenerateGoogleAuthenticatorSetupCodePost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserGetVerificationLevelGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVerificationLevelResponse>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserGetVerificationLevelGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserOrdersGet(pair?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrdersResponse>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserOrdersGet(pair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [phoneNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSetPhoneNumberPost(phoneNumber?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResource>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserSetPhoneNumberPost(phoneNumber, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [pairId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserTradehistoryGet(pairId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserTradehistoryGet(pairId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserVerificationsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserVerificationsGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserVerificationtypeGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoStepVerificationTypes>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserVerificationtypeGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [gcode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserVerifyGoogleAuthenticatorSetupCodePost(gcode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BitflexApiResponseBase>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserVerifyGoogleAuthenticatorSetupCodePost(gcode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PostVefirySms} [postVefirySms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserVerifyPhoneNumberPost(postVefirySms?: PostVefirySms, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmsVefiryResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserVerifyPhoneNumberPost(postVefirySms, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserWithdrawalsGet(currency?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiGetDepositsWitdrawals>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).apiUserWithdrawalsGet(currency, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAffiliateGet(options?: any): AxiosPromise<AffiliateDataResponse> {
            return UserApiFp(configuration).apiUserAffiliateGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserAffiliatePost(options?: any): AxiosPromise<AffiliateDataResponse> {
            return UserApiFp(configuration).apiUserAffiliatePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [bfApiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApikeysDelete(bfApiKey?: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserApikeysDelete(bfApiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApikeysGet(options?: any): AxiosPromise<Array<ApiKey>> {
            return UserApiFp(configuration).apiUserApikeysGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateApiKeyRequest} [generateApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserApikeysPost(generateApiKeyRequest?: GenerateApiKeyRequest, options?: any): AxiosPromise<ApiKey> {
            return UserApiFp(configuration).apiUserApikeysPost(generateApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceactionsGet(page?: number, size?: number, options?: any): AxiosPromise<GetBalanceActionsResponse> {
            return UserApiFp(configuration).apiUserBalanceactionsGet(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalancesGet(options?: any): AxiosPromise<{ [key: string]: number; }> {
            return UserApiFp(configuration).apiUserBalancesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserBalanceslistGet(options?: any): AxiosPromise<GetBalancesListResponse> {
            return UserApiFp(configuration).apiUserBalanceslistGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDepositsGet(currency?: string, options?: any): AxiosPromise<Array<ApiGetDepositsWitdrawals>> {
            return UserApiFp(configuration).apiUserDepositsGet(currency, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [gcode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDisableGoogleAuthenticatorDelete(gcode?: string, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return UserApiFp(configuration).apiUserDisableGoogleAuthenticatorDelete(gcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [backupCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserDisableGoogleAuthenticatorWithBackupCodeDelete(backupCode?: string, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return UserApiFp(configuration).apiUserDisableGoogleAuthenticatorWithBackupCodeDelete(backupCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FinishTier1VerificationModel} [finishTier1VerificationModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFinishTier1VerificationPost(finishTier1VerificationModel?: FinishTier1VerificationModel, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return UserApiFp(configuration).apiUserFinishTier1VerificationPost(finishTier1VerificationModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGenerateGoogleAuthenticatorSetupCodePost(options?: any): AxiosPromise<SetupCode> {
            return UserApiFp(configuration).apiUserGenerateGoogleAuthenticatorSetupCodePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserGetVerificationLevelGet(options?: any): AxiosPromise<GetVerificationLevelResponse> {
            return UserApiFp(configuration).apiUserGetVerificationLevelGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pair] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserOrdersGet(pair?: string, options?: any): AxiosPromise<GetOrdersResponse> {
            return UserApiFp(configuration).apiUserOrdersGet(pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [phoneNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSetPhoneNumberPost(phoneNumber?: string, options?: any): AxiosPromise<VerificationResource> {
            return UserApiFp(configuration).apiUserSetPhoneNumberPost(phoneNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [pairId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserTradehistoryGet(pairId?: string, options?: any): AxiosPromise<Array<Order>> {
            return UserApiFp(configuration).apiUserTradehistoryGet(pairId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerificationsGet(options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).apiUserVerificationsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerificationtypeGet(options?: any): AxiosPromise<TwoStepVerificationTypes> {
            return UserApiFp(configuration).apiUserVerificationtypeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [gcode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerifyGoogleAuthenticatorSetupCodePost(gcode?: string, options?: any): AxiosPromise<BitflexApiResponseBase> {
            return UserApiFp(configuration).apiUserVerifyGoogleAuthenticatorSetupCodePost(gcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PostVefirySms} [postVefirySms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserVerifyPhoneNumberPost(postVefirySms?: PostVefirySms, options?: any): AxiosPromise<SmsVefiryResult> {
            return UserApiFp(configuration).apiUserVerifyPhoneNumberPost(postVefirySms, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [currency] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserWithdrawalsGet(currency?: string, options?: any): AxiosPromise<Array<ApiGetDepositsWitdrawals>> {
            return UserApiFp(configuration).apiUserWithdrawalsGet(currency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserAffiliateGet(options?: any) {
        return UserApiFp(this.configuration).apiUserAffiliateGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserAffiliatePost(options?: any) {
        return UserApiFp(this.configuration).apiUserAffiliatePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [bfApiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserApikeysDelete(bfApiKey?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserApikeysDelete(bfApiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserApikeysGet(options?: any) {
        return UserApiFp(this.configuration).apiUserApikeysGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateApiKeyRequest} [generateApiKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserApikeysPost(generateApiKeyRequest?: GenerateApiKeyRequest, options?: any) {
        return UserApiFp(this.configuration).apiUserApikeysPost(generateApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserBalanceactionsGet(page?: number, size?: number, options?: any) {
        return UserApiFp(this.configuration).apiUserBalanceactionsGet(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserBalancesGet(options?: any) {
        return UserApiFp(this.configuration).apiUserBalancesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserBalanceslistGet(options?: any) {
        return UserApiFp(this.configuration).apiUserBalanceslistGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserDepositsGet(currency?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserDepositsGet(currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [gcode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserDisableGoogleAuthenticatorDelete(gcode?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserDisableGoogleAuthenticatorDelete(gcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [backupCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserDisableGoogleAuthenticatorWithBackupCodeDelete(backupCode?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserDisableGoogleAuthenticatorWithBackupCodeDelete(backupCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FinishTier1VerificationModel} [finishTier1VerificationModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserFinishTier1VerificationPost(finishTier1VerificationModel?: FinishTier1VerificationModel, options?: any) {
        return UserApiFp(this.configuration).apiUserFinishTier1VerificationPost(finishTier1VerificationModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserGenerateGoogleAuthenticatorSetupCodePost(options?: any) {
        return UserApiFp(this.configuration).apiUserGenerateGoogleAuthenticatorSetupCodePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserGetVerificationLevelGet(options?: any) {
        return UserApiFp(this.configuration).apiUserGetVerificationLevelGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pair] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserOrdersGet(pair?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserOrdersGet(pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [phoneNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserSetPhoneNumberPost(phoneNumber?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserSetPhoneNumberPost(phoneNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [pairId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserTradehistoryGet(pairId?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserTradehistoryGet(pairId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserVerificationsGet(options?: any) {
        return UserApiFp(this.configuration).apiUserVerificationsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserVerificationtypeGet(options?: any) {
        return UserApiFp(this.configuration).apiUserVerificationtypeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [gcode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserVerifyGoogleAuthenticatorSetupCodePost(gcode?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserVerifyGoogleAuthenticatorSetupCodePost(gcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PostVefirySms} [postVefirySms] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserVerifyPhoneNumberPost(postVefirySms?: PostVefirySms, options?: any) {
        return UserApiFp(this.configuration).apiUserVerifyPhoneNumberPost(postVefirySms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [currency] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public apiUserWithdrawalsGet(currency?: string, options?: any) {
        return UserApiFp(this.configuration).apiUserWithdrawalsGet(currency, options).then((request) => request(this.axios, this.basePath));
    }
}


